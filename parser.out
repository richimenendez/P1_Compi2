Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    PORCENTAJE
    SXOR

Grammar

Rule 0     S' -> s
Rule 1     s -> ltag
Rule 2     ltag -> ltag tag linst
Rule 3     ltag -> tag linst
Rule 4     linst -> linst inst PCOMA
Rule 5     linst -> inst PCOMA
Rule 6     inst -> asignacion
Rule 7     inst -> iff
Rule 8     inst -> jump
Rule 9     inst -> printt
Rule 10    inst -> ext
Rule 11    inst -> uns
Rule 12    uns -> unset IZQPAR va DERPAR
Rule 13    asignacion -> var2 IGUAL exp
Rule 14    var2 -> VAR arr
Rule 15    var2 -> VAR
Rule 16    tag -> ID DP
Rule 17    tag -> main DP
Rule 18    jump -> goto ID
Rule 19    iff -> if IZQPAR exp DERPAR goto ID
Rule 20    printt -> print IZQPAR E DERPAR
Rule 21    ext -> exit
Rule 22    exp -> expa
Rule 23    exp -> expl
Rule 24    exp -> expra
Rule 25    exp -> expb
Rule 26    exp -> casteo
Rule 27    exp -> E
Rule 28    exp -> calls
Rule 29    casteo -> IZQPAR int DERPAR E
Rule 30    casteo -> IZQPAR float DERPAR E
Rule 31    casteo -> IZQPAR char DERPAR E
Rule 32    calls -> read IZQPAR DERPAR
Rule 33    calls -> array IZQPAR DERPAR
Rule 34    calls -> PUNTERO VAR
Rule 35    expl -> NOT E
Rule 36    expl -> E AND E
Rule 37    expl -> E OR E
Rule 38    expl -> E xor E
Rule 39    expra -> E DIGUAL E
Rule 40    expra -> E DESIGUAL E
Rule 41    expra -> E MAYORIGUAL E
Rule 42    expra -> E MENORIGUAL E
Rule 43    expra -> E MAYOR E
Rule 44    expra -> E MENOR E
Rule 45    expb -> BNOT E
Rule 46    expb -> E BAND E
Rule 47    expb -> E BOR E
Rule 48    expb -> E BXOR E
Rule 49    expb -> E BLEFT E
Rule 50    expb -> E BRIGHT E
Rule 51    expa -> E SUMA E
Rule 52    expa -> E RESTA E
Rule 53    expa -> E MULTI E
Rule 54    expa -> abs IZQPAR E DERPAR
Rule 55    expa -> E DIV E
Rule 56    E -> ent
Rule 57    E -> dou
Rule 58    E -> va
Rule 59    E -> str
Rule 60    E -> RESTA E
Rule 61    ent -> INTEGER
Rule 62    dou -> DOUBLE
Rule 63    str -> STR
Rule 64    va -> VAR arr
Rule 65    va -> VAR
Rule 66    arr -> arr IZQLLAVE E DERLLAVE
Rule 67    arr -> IZQLLAVE E DERLLAVE

Terminals, with rules where they appear

AND                  : 36
BAND                 : 46
BLEFT                : 49
BNOT                 : 45
BOR                  : 47
BRIGHT               : 50
BXOR                 : 48
DERLLAVE             : 66 67
DERPAR               : 12 19 20 29 30 31 32 33 54
DESIGUAL             : 40
DIGUAL               : 39
DIV                  : 55
DOUBLE               : 62
DP                   : 16 17
ID                   : 16 18 19
IGUAL                : 13
INTEGER              : 61
IZQLLAVE             : 66 67
IZQPAR               : 12 19 20 29 30 31 32 33 54
MAYOR                : 43
MAYORIGUAL           : 41
MENOR                : 44
MENORIGUAL           : 42
MULTI                : 53
NOT                  : 35
OR                   : 37
PCOMA                : 4 5
PORCENTAJE           : 
PUNTERO              : 34
RESTA                : 52 60
STR                  : 63
SUMA                 : 51
SXOR                 : 
VAR                  : 14 15 34 64 65
abs                  : 54
array                : 33
char                 : 31
error                : 
exit                 : 21
float                : 30
goto                 : 18 19
if                   : 19
int                  : 29
main                 : 17
print                : 20
read                 : 32
unset                : 12
xor                  : 38

Nonterminals, with rules where they appear

E                    : 20 27 29 30 31 35 36 36 37 37 38 38 39 39 40 40 41 41 42 42 43 43 44 44 45 46 46 47 47 48 48 49 49 50 50 51 51 52 52 53 53 54 55 55 60 66 67
arr                  : 14 64 66
asignacion           : 6
calls                : 28
casteo               : 26
dou                  : 57
ent                  : 56
exp                  : 13 19
expa                 : 22
expb                 : 25
expl                 : 23
expra                : 24
ext                  : 10
iff                  : 7
inst                 : 4 5
jump                 : 8
linst                : 2 3 4
ltag                 : 1 2
printt               : 9
s                    : 0
str                  : 59
tag                  : 2 3
uns                  : 11
va                   : 12 58
var2                 : 13

Parsing method: LALR

state 0

    (0) S' -> . s
    (1) s -> . ltag
    (2) ltag -> . ltag tag linst
    (3) ltag -> . tag linst
    (16) tag -> . ID DP
    (17) tag -> . main DP

    ID              shift and go to state 4
    main            shift and go to state 5

    s                              shift and go to state 1
    ltag                           shift and go to state 2
    tag                            shift and go to state 3

state 1

    (0) S' -> s .



state 2

    (1) s -> ltag .
    (2) ltag -> ltag . tag linst
    (16) tag -> . ID DP
    (17) tag -> . main DP

    $end            reduce using rule 1 (s -> ltag .)
    ID              shift and go to state 4
    main            shift and go to state 5

    tag                            shift and go to state 6

state 3

    (3) ltag -> tag . linst
    (4) linst -> . linst inst PCOMA
    (5) linst -> . inst PCOMA
    (6) inst -> . asignacion
    (7) inst -> . iff
    (8) inst -> . jump
    (9) inst -> . printt
    (10) inst -> . ext
    (11) inst -> . uns
    (13) asignacion -> . var2 IGUAL exp
    (19) iff -> . if IZQPAR exp DERPAR goto ID
    (18) jump -> . goto ID
    (20) printt -> . print IZQPAR E DERPAR
    (21) ext -> . exit
    (12) uns -> . unset IZQPAR va DERPAR
    (14) var2 -> . VAR arr
    (15) var2 -> . VAR

    if              shift and go to state 16
    goto            shift and go to state 17
    print           shift and go to state 18
    exit            shift and go to state 19
    unset           shift and go to state 20
    VAR             shift and go to state 21

    linst                          shift and go to state 7
    inst                           shift and go to state 8
    asignacion                     shift and go to state 9
    iff                            shift and go to state 10
    jump                           shift and go to state 11
    printt                         shift and go to state 12
    ext                            shift and go to state 13
    uns                            shift and go to state 14
    var2                           shift and go to state 15

state 4

    (16) tag -> ID . DP

    DP              shift and go to state 22


state 5

    (17) tag -> main . DP

    DP              shift and go to state 23


state 6

    (2) ltag -> ltag tag . linst
    (4) linst -> . linst inst PCOMA
    (5) linst -> . inst PCOMA
    (6) inst -> . asignacion
    (7) inst -> . iff
    (8) inst -> . jump
    (9) inst -> . printt
    (10) inst -> . ext
    (11) inst -> . uns
    (13) asignacion -> . var2 IGUAL exp
    (19) iff -> . if IZQPAR exp DERPAR goto ID
    (18) jump -> . goto ID
    (20) printt -> . print IZQPAR E DERPAR
    (21) ext -> . exit
    (12) uns -> . unset IZQPAR va DERPAR
    (14) var2 -> . VAR arr
    (15) var2 -> . VAR

    if              shift and go to state 16
    goto            shift and go to state 17
    print           shift and go to state 18
    exit            shift and go to state 19
    unset           shift and go to state 20
    VAR             shift and go to state 21

    linst                          shift and go to state 24
    inst                           shift and go to state 8
    asignacion                     shift and go to state 9
    iff                            shift and go to state 10
    jump                           shift and go to state 11
    printt                         shift and go to state 12
    ext                            shift and go to state 13
    uns                            shift and go to state 14
    var2                           shift and go to state 15

state 7

    (3) ltag -> tag linst .
    (4) linst -> linst . inst PCOMA
    (6) inst -> . asignacion
    (7) inst -> . iff
    (8) inst -> . jump
    (9) inst -> . printt
    (10) inst -> . ext
    (11) inst -> . uns
    (13) asignacion -> . var2 IGUAL exp
    (19) iff -> . if IZQPAR exp DERPAR goto ID
    (18) jump -> . goto ID
    (20) printt -> . print IZQPAR E DERPAR
    (21) ext -> . exit
    (12) uns -> . unset IZQPAR va DERPAR
    (14) var2 -> . VAR arr
    (15) var2 -> . VAR

    ID              reduce using rule 3 (ltag -> tag linst .)
    main            reduce using rule 3 (ltag -> tag linst .)
    $end            reduce using rule 3 (ltag -> tag linst .)
    if              shift and go to state 16
    goto            shift and go to state 17
    print           shift and go to state 18
    exit            shift and go to state 19
    unset           shift and go to state 20
    VAR             shift and go to state 21

    inst                           shift and go to state 25
    asignacion                     shift and go to state 9
    iff                            shift and go to state 10
    jump                           shift and go to state 11
    printt                         shift and go to state 12
    ext                            shift and go to state 13
    uns                            shift and go to state 14
    var2                           shift and go to state 15

state 8

    (5) linst -> inst . PCOMA

    PCOMA           shift and go to state 26


state 9

    (6) inst -> asignacion .

    PCOMA           reduce using rule 6 (inst -> asignacion .)


state 10

    (7) inst -> iff .

    PCOMA           reduce using rule 7 (inst -> iff .)


state 11

    (8) inst -> jump .

    PCOMA           reduce using rule 8 (inst -> jump .)


state 12

    (9) inst -> printt .

    PCOMA           reduce using rule 9 (inst -> printt .)


state 13

    (10) inst -> ext .

    PCOMA           reduce using rule 10 (inst -> ext .)


state 14

    (11) inst -> uns .

    PCOMA           reduce using rule 11 (inst -> uns .)


state 15

    (13) asignacion -> var2 . IGUAL exp

    IGUAL           shift and go to state 27


state 16

    (19) iff -> if . IZQPAR exp DERPAR goto ID

    IZQPAR          shift and go to state 28


state 17

    (18) jump -> goto . ID

    ID              shift and go to state 29


state 18

    (20) printt -> print . IZQPAR E DERPAR

    IZQPAR          shift and go to state 30


state 19

    (21) ext -> exit .

    PCOMA           reduce using rule 21 (ext -> exit .)


state 20

    (12) uns -> unset . IZQPAR va DERPAR

    IZQPAR          shift and go to state 31


state 21

    (14) var2 -> VAR . arr
    (15) var2 -> VAR .
    (66) arr -> . arr IZQLLAVE E DERLLAVE
    (67) arr -> . IZQLLAVE E DERLLAVE

    IGUAL           reduce using rule 15 (var2 -> VAR .)
    IZQLLAVE        shift and go to state 33

    arr                            shift and go to state 32

state 22

    (16) tag -> ID DP .

    if              reduce using rule 16 (tag -> ID DP .)
    goto            reduce using rule 16 (tag -> ID DP .)
    print           reduce using rule 16 (tag -> ID DP .)
    exit            reduce using rule 16 (tag -> ID DP .)
    unset           reduce using rule 16 (tag -> ID DP .)
    VAR             reduce using rule 16 (tag -> ID DP .)


state 23

    (17) tag -> main DP .

    if              reduce using rule 17 (tag -> main DP .)
    goto            reduce using rule 17 (tag -> main DP .)
    print           reduce using rule 17 (tag -> main DP .)
    exit            reduce using rule 17 (tag -> main DP .)
    unset           reduce using rule 17 (tag -> main DP .)
    VAR             reduce using rule 17 (tag -> main DP .)


state 24

    (2) ltag -> ltag tag linst .
    (4) linst -> linst . inst PCOMA
    (6) inst -> . asignacion
    (7) inst -> . iff
    (8) inst -> . jump
    (9) inst -> . printt
    (10) inst -> . ext
    (11) inst -> . uns
    (13) asignacion -> . var2 IGUAL exp
    (19) iff -> . if IZQPAR exp DERPAR goto ID
    (18) jump -> . goto ID
    (20) printt -> . print IZQPAR E DERPAR
    (21) ext -> . exit
    (12) uns -> . unset IZQPAR va DERPAR
    (14) var2 -> . VAR arr
    (15) var2 -> . VAR

    ID              reduce using rule 2 (ltag -> ltag tag linst .)
    main            reduce using rule 2 (ltag -> ltag tag linst .)
    $end            reduce using rule 2 (ltag -> ltag tag linst .)
    if              shift and go to state 16
    goto            shift and go to state 17
    print           shift and go to state 18
    exit            shift and go to state 19
    unset           shift and go to state 20
    VAR             shift and go to state 21

    inst                           shift and go to state 25
    asignacion                     shift and go to state 9
    iff                            shift and go to state 10
    jump                           shift and go to state 11
    printt                         shift and go to state 12
    ext                            shift and go to state 13
    uns                            shift and go to state 14
    var2                           shift and go to state 15

state 25

    (4) linst -> linst inst . PCOMA

    PCOMA           shift and go to state 34


state 26

    (5) linst -> inst PCOMA .

    if              reduce using rule 5 (linst -> inst PCOMA .)
    goto            reduce using rule 5 (linst -> inst PCOMA .)
    print           reduce using rule 5 (linst -> inst PCOMA .)
    exit            reduce using rule 5 (linst -> inst PCOMA .)
    unset           reduce using rule 5 (linst -> inst PCOMA .)
    VAR             reduce using rule 5 (linst -> inst PCOMA .)
    ID              reduce using rule 5 (linst -> inst PCOMA .)
    main            reduce using rule 5 (linst -> inst PCOMA .)
    $end            reduce using rule 5 (linst -> inst PCOMA .)


state 27

    (13) asignacion -> var2 IGUAL . exp
    (22) exp -> . expa
    (23) exp -> . expl
    (24) exp -> . expra
    (25) exp -> . expb
    (26) exp -> . casteo
    (27) exp -> . E
    (28) exp -> . calls
    (51) expa -> . E SUMA E
    (52) expa -> . E RESTA E
    (53) expa -> . E MULTI E
    (54) expa -> . abs IZQPAR E DERPAR
    (55) expa -> . E DIV E
    (35) expl -> . NOT E
    (36) expl -> . E AND E
    (37) expl -> . E OR E
    (38) expl -> . E xor E
    (39) expra -> . E DIGUAL E
    (40) expra -> . E DESIGUAL E
    (41) expra -> . E MAYORIGUAL E
    (42) expra -> . E MENORIGUAL E
    (43) expra -> . E MAYOR E
    (44) expra -> . E MENOR E
    (45) expb -> . BNOT E
    (46) expb -> . E BAND E
    (47) expb -> . E BOR E
    (48) expb -> . E BXOR E
    (49) expb -> . E BLEFT E
    (50) expb -> . E BRIGHT E
    (29) casteo -> . IZQPAR int DERPAR E
    (30) casteo -> . IZQPAR float DERPAR E
    (31) casteo -> . IZQPAR char DERPAR E
    (56) E -> . ent
    (57) E -> . dou
    (58) E -> . va
    (59) E -> . str
    (60) E -> . RESTA E
    (32) calls -> . read IZQPAR DERPAR
    (33) calls -> . array IZQPAR DERPAR
    (34) calls -> . PUNTERO VAR
    (61) ent -> . INTEGER
    (62) dou -> . DOUBLE
    (64) va -> . VAR arr
    (65) va -> . VAR
    (63) str -> . STR

    abs             shift and go to state 44
    NOT             shift and go to state 46
    BNOT            shift and go to state 47
    IZQPAR          shift and go to state 45
    RESTA           shift and go to state 43
    read            shift and go to state 52
    array           shift and go to state 53
    PUNTERO         shift and go to state 54
    INTEGER         shift and go to state 56
    DOUBLE          shift and go to state 57
    VAR             shift and go to state 55
    STR             shift and go to state 58

    exp                            shift and go to state 35
    expa                           shift and go to state 36
    expl                           shift and go to state 37
    expra                          shift and go to state 38
    expb                           shift and go to state 39
    casteo                         shift and go to state 40
    E                              shift and go to state 41
    calls                          shift and go to state 42
    ent                            shift and go to state 48
    dou                            shift and go to state 49
    va                             shift and go to state 50
    str                            shift and go to state 51

state 28

    (19) iff -> if IZQPAR . exp DERPAR goto ID
    (22) exp -> . expa
    (23) exp -> . expl
    (24) exp -> . expra
    (25) exp -> . expb
    (26) exp -> . casteo
    (27) exp -> . E
    (28) exp -> . calls
    (51) expa -> . E SUMA E
    (52) expa -> . E RESTA E
    (53) expa -> . E MULTI E
    (54) expa -> . abs IZQPAR E DERPAR
    (55) expa -> . E DIV E
    (35) expl -> . NOT E
    (36) expl -> . E AND E
    (37) expl -> . E OR E
    (38) expl -> . E xor E
    (39) expra -> . E DIGUAL E
    (40) expra -> . E DESIGUAL E
    (41) expra -> . E MAYORIGUAL E
    (42) expra -> . E MENORIGUAL E
    (43) expra -> . E MAYOR E
    (44) expra -> . E MENOR E
    (45) expb -> . BNOT E
    (46) expb -> . E BAND E
    (47) expb -> . E BOR E
    (48) expb -> . E BXOR E
    (49) expb -> . E BLEFT E
    (50) expb -> . E BRIGHT E
    (29) casteo -> . IZQPAR int DERPAR E
    (30) casteo -> . IZQPAR float DERPAR E
    (31) casteo -> . IZQPAR char DERPAR E
    (56) E -> . ent
    (57) E -> . dou
    (58) E -> . va
    (59) E -> . str
    (60) E -> . RESTA E
    (32) calls -> . read IZQPAR DERPAR
    (33) calls -> . array IZQPAR DERPAR
    (34) calls -> . PUNTERO VAR
    (61) ent -> . INTEGER
    (62) dou -> . DOUBLE
    (64) va -> . VAR arr
    (65) va -> . VAR
    (63) str -> . STR

    abs             shift and go to state 44
    NOT             shift and go to state 46
    BNOT            shift and go to state 47
    IZQPAR          shift and go to state 45
    RESTA           shift and go to state 43
    read            shift and go to state 52
    array           shift and go to state 53
    PUNTERO         shift and go to state 54
    INTEGER         shift and go to state 56
    DOUBLE          shift and go to state 57
    VAR             shift and go to state 55
    STR             shift and go to state 58

    exp                            shift and go to state 59
    expa                           shift and go to state 36
    expl                           shift and go to state 37
    expra                          shift and go to state 38
    expb                           shift and go to state 39
    casteo                         shift and go to state 40
    E                              shift and go to state 41
    calls                          shift and go to state 42
    ent                            shift and go to state 48
    dou                            shift and go to state 49
    va                             shift and go to state 50
    str                            shift and go to state 51

state 29

    (18) jump -> goto ID .

    PCOMA           reduce using rule 18 (jump -> goto ID .)


state 30

    (20) printt -> print IZQPAR . E DERPAR
    (56) E -> . ent
    (57) E -> . dou
    (58) E -> . va
    (59) E -> . str
    (60) E -> . RESTA E
    (61) ent -> . INTEGER
    (62) dou -> . DOUBLE
    (64) va -> . VAR arr
    (65) va -> . VAR
    (63) str -> . STR

    RESTA           shift and go to state 43
    INTEGER         shift and go to state 56
    DOUBLE          shift and go to state 57
    VAR             shift and go to state 55
    STR             shift and go to state 58

    E                              shift and go to state 60
    ent                            shift and go to state 48
    dou                            shift and go to state 49
    va                             shift and go to state 50
    str                            shift and go to state 51

state 31

    (12) uns -> unset IZQPAR . va DERPAR
    (64) va -> . VAR arr
    (65) va -> . VAR

    VAR             shift and go to state 55

    va                             shift and go to state 61

state 32

    (14) var2 -> VAR arr .
    (66) arr -> arr . IZQLLAVE E DERLLAVE

    IGUAL           reduce using rule 14 (var2 -> VAR arr .)
    IZQLLAVE        shift and go to state 62


state 33

    (67) arr -> IZQLLAVE . E DERLLAVE
    (56) E -> . ent
    (57) E -> . dou
    (58) E -> . va
    (59) E -> . str
    (60) E -> . RESTA E
    (61) ent -> . INTEGER
    (62) dou -> . DOUBLE
    (64) va -> . VAR arr
    (65) va -> . VAR
    (63) str -> . STR

    RESTA           shift and go to state 43
    INTEGER         shift and go to state 56
    DOUBLE          shift and go to state 57
    VAR             shift and go to state 55
    STR             shift and go to state 58

    E                              shift and go to state 63
    ent                            shift and go to state 48
    dou                            shift and go to state 49
    va                             shift and go to state 50
    str                            shift and go to state 51

state 34

    (4) linst -> linst inst PCOMA .

    if              reduce using rule 4 (linst -> linst inst PCOMA .)
    goto            reduce using rule 4 (linst -> linst inst PCOMA .)
    print           reduce using rule 4 (linst -> linst inst PCOMA .)
    exit            reduce using rule 4 (linst -> linst inst PCOMA .)
    unset           reduce using rule 4 (linst -> linst inst PCOMA .)
    VAR             reduce using rule 4 (linst -> linst inst PCOMA .)
    ID              reduce using rule 4 (linst -> linst inst PCOMA .)
    main            reduce using rule 4 (linst -> linst inst PCOMA .)
    $end            reduce using rule 4 (linst -> linst inst PCOMA .)


state 35

    (13) asignacion -> var2 IGUAL exp .

    PCOMA           reduce using rule 13 (asignacion -> var2 IGUAL exp .)


state 36

    (22) exp -> expa .

    PCOMA           reduce using rule 22 (exp -> expa .)
    DERPAR          reduce using rule 22 (exp -> expa .)


state 37

    (23) exp -> expl .

    PCOMA           reduce using rule 23 (exp -> expl .)
    DERPAR          reduce using rule 23 (exp -> expl .)


state 38

    (24) exp -> expra .

    PCOMA           reduce using rule 24 (exp -> expra .)
    DERPAR          reduce using rule 24 (exp -> expra .)


state 39

    (25) exp -> expb .

    PCOMA           reduce using rule 25 (exp -> expb .)
    DERPAR          reduce using rule 25 (exp -> expb .)


state 40

    (26) exp -> casteo .

    PCOMA           reduce using rule 26 (exp -> casteo .)
    DERPAR          reduce using rule 26 (exp -> casteo .)


state 41

    (27) exp -> E .
    (51) expa -> E . SUMA E
    (52) expa -> E . RESTA E
    (53) expa -> E . MULTI E
    (55) expa -> E . DIV E
    (36) expl -> E . AND E
    (37) expl -> E . OR E
    (38) expl -> E . xor E
    (39) expra -> E . DIGUAL E
    (40) expra -> E . DESIGUAL E
    (41) expra -> E . MAYORIGUAL E
    (42) expra -> E . MENORIGUAL E
    (43) expra -> E . MAYOR E
    (44) expra -> E . MENOR E
    (46) expb -> E . BAND E
    (47) expb -> E . BOR E
    (48) expb -> E . BXOR E
    (49) expb -> E . BLEFT E
    (50) expb -> E . BRIGHT E

    PCOMA           reduce using rule 27 (exp -> E .)
    DERPAR          reduce using rule 27 (exp -> E .)
    SUMA            shift and go to state 64
    RESTA           shift and go to state 65
    MULTI           shift and go to state 66
    DIV             shift and go to state 67
    AND             shift and go to state 68
    OR              shift and go to state 69
    xor             shift and go to state 70
    DIGUAL          shift and go to state 71
    DESIGUAL        shift and go to state 72
    MAYORIGUAL      shift and go to state 73
    MENORIGUAL      shift and go to state 74
    MAYOR           shift and go to state 75
    MENOR           shift and go to state 76
    BAND            shift and go to state 77
    BOR             shift and go to state 78
    BXOR            shift and go to state 79
    BLEFT           shift and go to state 80
    BRIGHT          shift and go to state 81


state 42

    (28) exp -> calls .

    PCOMA           reduce using rule 28 (exp -> calls .)
    DERPAR          reduce using rule 28 (exp -> calls .)


state 43

    (60) E -> RESTA . E
    (56) E -> . ent
    (57) E -> . dou
    (58) E -> . va
    (59) E -> . str
    (60) E -> . RESTA E
    (61) ent -> . INTEGER
    (62) dou -> . DOUBLE
    (64) va -> . VAR arr
    (65) va -> . VAR
    (63) str -> . STR

    RESTA           shift and go to state 43
    INTEGER         shift and go to state 56
    DOUBLE          shift and go to state 57
    VAR             shift and go to state 55
    STR             shift and go to state 58

    E                              shift and go to state 82
    ent                            shift and go to state 48
    dou                            shift and go to state 49
    va                             shift and go to state 50
    str                            shift and go to state 51

state 44

    (54) expa -> abs . IZQPAR E DERPAR

    IZQPAR          shift and go to state 83


state 45

    (29) casteo -> IZQPAR . int DERPAR E
    (30) casteo -> IZQPAR . float DERPAR E
    (31) casteo -> IZQPAR . char DERPAR E

    int             shift and go to state 84
    float           shift and go to state 85
    char            shift and go to state 86


state 46

    (35) expl -> NOT . E
    (56) E -> . ent
    (57) E -> . dou
    (58) E -> . va
    (59) E -> . str
    (60) E -> . RESTA E
    (61) ent -> . INTEGER
    (62) dou -> . DOUBLE
    (64) va -> . VAR arr
    (65) va -> . VAR
    (63) str -> . STR

    RESTA           shift and go to state 43
    INTEGER         shift and go to state 56
    DOUBLE          shift and go to state 57
    VAR             shift and go to state 55
    STR             shift and go to state 58

    E                              shift and go to state 87
    ent                            shift and go to state 48
    dou                            shift and go to state 49
    va                             shift and go to state 50
    str                            shift and go to state 51

state 47

    (45) expb -> BNOT . E
    (56) E -> . ent
    (57) E -> . dou
    (58) E -> . va
    (59) E -> . str
    (60) E -> . RESTA E
    (61) ent -> . INTEGER
    (62) dou -> . DOUBLE
    (64) va -> . VAR arr
    (65) va -> . VAR
    (63) str -> . STR

    RESTA           shift and go to state 43
    INTEGER         shift and go to state 56
    DOUBLE          shift and go to state 57
    VAR             shift and go to state 55
    STR             shift and go to state 58

    E                              shift and go to state 88
    ent                            shift and go to state 48
    dou                            shift and go to state 49
    va                             shift and go to state 50
    str                            shift and go to state 51

state 48

    (56) E -> ent .

    SUMA            reduce using rule 56 (E -> ent .)
    RESTA           reduce using rule 56 (E -> ent .)
    MULTI           reduce using rule 56 (E -> ent .)
    DIV             reduce using rule 56 (E -> ent .)
    AND             reduce using rule 56 (E -> ent .)
    OR              reduce using rule 56 (E -> ent .)
    xor             reduce using rule 56 (E -> ent .)
    DIGUAL          reduce using rule 56 (E -> ent .)
    DESIGUAL        reduce using rule 56 (E -> ent .)
    MAYORIGUAL      reduce using rule 56 (E -> ent .)
    MENORIGUAL      reduce using rule 56 (E -> ent .)
    MAYOR           reduce using rule 56 (E -> ent .)
    MENOR           reduce using rule 56 (E -> ent .)
    BAND            reduce using rule 56 (E -> ent .)
    BOR             reduce using rule 56 (E -> ent .)
    BXOR            reduce using rule 56 (E -> ent .)
    BLEFT           reduce using rule 56 (E -> ent .)
    BRIGHT          reduce using rule 56 (E -> ent .)
    PCOMA           reduce using rule 56 (E -> ent .)
    DERPAR          reduce using rule 56 (E -> ent .)
    DERLLAVE        reduce using rule 56 (E -> ent .)


state 49

    (57) E -> dou .

    SUMA            reduce using rule 57 (E -> dou .)
    RESTA           reduce using rule 57 (E -> dou .)
    MULTI           reduce using rule 57 (E -> dou .)
    DIV             reduce using rule 57 (E -> dou .)
    AND             reduce using rule 57 (E -> dou .)
    OR              reduce using rule 57 (E -> dou .)
    xor             reduce using rule 57 (E -> dou .)
    DIGUAL          reduce using rule 57 (E -> dou .)
    DESIGUAL        reduce using rule 57 (E -> dou .)
    MAYORIGUAL      reduce using rule 57 (E -> dou .)
    MENORIGUAL      reduce using rule 57 (E -> dou .)
    MAYOR           reduce using rule 57 (E -> dou .)
    MENOR           reduce using rule 57 (E -> dou .)
    BAND            reduce using rule 57 (E -> dou .)
    BOR             reduce using rule 57 (E -> dou .)
    BXOR            reduce using rule 57 (E -> dou .)
    BLEFT           reduce using rule 57 (E -> dou .)
    BRIGHT          reduce using rule 57 (E -> dou .)
    PCOMA           reduce using rule 57 (E -> dou .)
    DERPAR          reduce using rule 57 (E -> dou .)
    DERLLAVE        reduce using rule 57 (E -> dou .)


state 50

    (58) E -> va .

    SUMA            reduce using rule 58 (E -> va .)
    RESTA           reduce using rule 58 (E -> va .)
    MULTI           reduce using rule 58 (E -> va .)
    DIV             reduce using rule 58 (E -> va .)
    AND             reduce using rule 58 (E -> va .)
    OR              reduce using rule 58 (E -> va .)
    xor             reduce using rule 58 (E -> va .)
    DIGUAL          reduce using rule 58 (E -> va .)
    DESIGUAL        reduce using rule 58 (E -> va .)
    MAYORIGUAL      reduce using rule 58 (E -> va .)
    MENORIGUAL      reduce using rule 58 (E -> va .)
    MAYOR           reduce using rule 58 (E -> va .)
    MENOR           reduce using rule 58 (E -> va .)
    BAND            reduce using rule 58 (E -> va .)
    BOR             reduce using rule 58 (E -> va .)
    BXOR            reduce using rule 58 (E -> va .)
    BLEFT           reduce using rule 58 (E -> va .)
    BRIGHT          reduce using rule 58 (E -> va .)
    PCOMA           reduce using rule 58 (E -> va .)
    DERPAR          reduce using rule 58 (E -> va .)
    DERLLAVE        reduce using rule 58 (E -> va .)


state 51

    (59) E -> str .

    SUMA            reduce using rule 59 (E -> str .)
    RESTA           reduce using rule 59 (E -> str .)
    MULTI           reduce using rule 59 (E -> str .)
    DIV             reduce using rule 59 (E -> str .)
    AND             reduce using rule 59 (E -> str .)
    OR              reduce using rule 59 (E -> str .)
    xor             reduce using rule 59 (E -> str .)
    DIGUAL          reduce using rule 59 (E -> str .)
    DESIGUAL        reduce using rule 59 (E -> str .)
    MAYORIGUAL      reduce using rule 59 (E -> str .)
    MENORIGUAL      reduce using rule 59 (E -> str .)
    MAYOR           reduce using rule 59 (E -> str .)
    MENOR           reduce using rule 59 (E -> str .)
    BAND            reduce using rule 59 (E -> str .)
    BOR             reduce using rule 59 (E -> str .)
    BXOR            reduce using rule 59 (E -> str .)
    BLEFT           reduce using rule 59 (E -> str .)
    BRIGHT          reduce using rule 59 (E -> str .)
    PCOMA           reduce using rule 59 (E -> str .)
    DERPAR          reduce using rule 59 (E -> str .)
    DERLLAVE        reduce using rule 59 (E -> str .)


state 52

    (32) calls -> read . IZQPAR DERPAR

    IZQPAR          shift and go to state 89


state 53

    (33) calls -> array . IZQPAR DERPAR

    IZQPAR          shift and go to state 90


state 54

    (34) calls -> PUNTERO . VAR

    VAR             shift and go to state 91


state 55

    (64) va -> VAR . arr
    (65) va -> VAR .
    (66) arr -> . arr IZQLLAVE E DERLLAVE
    (67) arr -> . IZQLLAVE E DERLLAVE

    SUMA            reduce using rule 65 (va -> VAR .)
    RESTA           reduce using rule 65 (va -> VAR .)
    MULTI           reduce using rule 65 (va -> VAR .)
    DIV             reduce using rule 65 (va -> VAR .)
    AND             reduce using rule 65 (va -> VAR .)
    OR              reduce using rule 65 (va -> VAR .)
    xor             reduce using rule 65 (va -> VAR .)
    DIGUAL          reduce using rule 65 (va -> VAR .)
    DESIGUAL        reduce using rule 65 (va -> VAR .)
    MAYORIGUAL      reduce using rule 65 (va -> VAR .)
    MENORIGUAL      reduce using rule 65 (va -> VAR .)
    MAYOR           reduce using rule 65 (va -> VAR .)
    MENOR           reduce using rule 65 (va -> VAR .)
    BAND            reduce using rule 65 (va -> VAR .)
    BOR             reduce using rule 65 (va -> VAR .)
    BXOR            reduce using rule 65 (va -> VAR .)
    BLEFT           reduce using rule 65 (va -> VAR .)
    BRIGHT          reduce using rule 65 (va -> VAR .)
    PCOMA           reduce using rule 65 (va -> VAR .)
    DERPAR          reduce using rule 65 (va -> VAR .)
    DERLLAVE        reduce using rule 65 (va -> VAR .)
    IZQLLAVE        shift and go to state 33

    arr                            shift and go to state 92

state 56

    (61) ent -> INTEGER .

    SUMA            reduce using rule 61 (ent -> INTEGER .)
    RESTA           reduce using rule 61 (ent -> INTEGER .)
    MULTI           reduce using rule 61 (ent -> INTEGER .)
    DIV             reduce using rule 61 (ent -> INTEGER .)
    AND             reduce using rule 61 (ent -> INTEGER .)
    OR              reduce using rule 61 (ent -> INTEGER .)
    xor             reduce using rule 61 (ent -> INTEGER .)
    DIGUAL          reduce using rule 61 (ent -> INTEGER .)
    DESIGUAL        reduce using rule 61 (ent -> INTEGER .)
    MAYORIGUAL      reduce using rule 61 (ent -> INTEGER .)
    MENORIGUAL      reduce using rule 61 (ent -> INTEGER .)
    MAYOR           reduce using rule 61 (ent -> INTEGER .)
    MENOR           reduce using rule 61 (ent -> INTEGER .)
    BAND            reduce using rule 61 (ent -> INTEGER .)
    BOR             reduce using rule 61 (ent -> INTEGER .)
    BXOR            reduce using rule 61 (ent -> INTEGER .)
    BLEFT           reduce using rule 61 (ent -> INTEGER .)
    BRIGHT          reduce using rule 61 (ent -> INTEGER .)
    PCOMA           reduce using rule 61 (ent -> INTEGER .)
    DERPAR          reduce using rule 61 (ent -> INTEGER .)
    DERLLAVE        reduce using rule 61 (ent -> INTEGER .)


state 57

    (62) dou -> DOUBLE .

    SUMA            reduce using rule 62 (dou -> DOUBLE .)
    RESTA           reduce using rule 62 (dou -> DOUBLE .)
    MULTI           reduce using rule 62 (dou -> DOUBLE .)
    DIV             reduce using rule 62 (dou -> DOUBLE .)
    AND             reduce using rule 62 (dou -> DOUBLE .)
    OR              reduce using rule 62 (dou -> DOUBLE .)
    xor             reduce using rule 62 (dou -> DOUBLE .)
    DIGUAL          reduce using rule 62 (dou -> DOUBLE .)
    DESIGUAL        reduce using rule 62 (dou -> DOUBLE .)
    MAYORIGUAL      reduce using rule 62 (dou -> DOUBLE .)
    MENORIGUAL      reduce using rule 62 (dou -> DOUBLE .)
    MAYOR           reduce using rule 62 (dou -> DOUBLE .)
    MENOR           reduce using rule 62 (dou -> DOUBLE .)
    BAND            reduce using rule 62 (dou -> DOUBLE .)
    BOR             reduce using rule 62 (dou -> DOUBLE .)
    BXOR            reduce using rule 62 (dou -> DOUBLE .)
    BLEFT           reduce using rule 62 (dou -> DOUBLE .)
    BRIGHT          reduce using rule 62 (dou -> DOUBLE .)
    PCOMA           reduce using rule 62 (dou -> DOUBLE .)
    DERPAR          reduce using rule 62 (dou -> DOUBLE .)
    DERLLAVE        reduce using rule 62 (dou -> DOUBLE .)


state 58

    (63) str -> STR .

    SUMA            reduce using rule 63 (str -> STR .)
    RESTA           reduce using rule 63 (str -> STR .)
    MULTI           reduce using rule 63 (str -> STR .)
    DIV             reduce using rule 63 (str -> STR .)
    AND             reduce using rule 63 (str -> STR .)
    OR              reduce using rule 63 (str -> STR .)
    xor             reduce using rule 63 (str -> STR .)
    DIGUAL          reduce using rule 63 (str -> STR .)
    DESIGUAL        reduce using rule 63 (str -> STR .)
    MAYORIGUAL      reduce using rule 63 (str -> STR .)
    MENORIGUAL      reduce using rule 63 (str -> STR .)
    MAYOR           reduce using rule 63 (str -> STR .)
    MENOR           reduce using rule 63 (str -> STR .)
    BAND            reduce using rule 63 (str -> STR .)
    BOR             reduce using rule 63 (str -> STR .)
    BXOR            reduce using rule 63 (str -> STR .)
    BLEFT           reduce using rule 63 (str -> STR .)
    BRIGHT          reduce using rule 63 (str -> STR .)
    PCOMA           reduce using rule 63 (str -> STR .)
    DERPAR          reduce using rule 63 (str -> STR .)
    DERLLAVE        reduce using rule 63 (str -> STR .)


state 59

    (19) iff -> if IZQPAR exp . DERPAR goto ID

    DERPAR          shift and go to state 93


state 60

    (20) printt -> print IZQPAR E . DERPAR

    DERPAR          shift and go to state 94


state 61

    (12) uns -> unset IZQPAR va . DERPAR

    DERPAR          shift and go to state 95


state 62

    (66) arr -> arr IZQLLAVE . E DERLLAVE
    (56) E -> . ent
    (57) E -> . dou
    (58) E -> . va
    (59) E -> . str
    (60) E -> . RESTA E
    (61) ent -> . INTEGER
    (62) dou -> . DOUBLE
    (64) va -> . VAR arr
    (65) va -> . VAR
    (63) str -> . STR

    RESTA           shift and go to state 43
    INTEGER         shift and go to state 56
    DOUBLE          shift and go to state 57
    VAR             shift and go to state 55
    STR             shift and go to state 58

    E                              shift and go to state 96
    ent                            shift and go to state 48
    dou                            shift and go to state 49
    va                             shift and go to state 50
    str                            shift and go to state 51

state 63

    (67) arr -> IZQLLAVE E . DERLLAVE

    DERLLAVE        shift and go to state 97


state 64

    (51) expa -> E SUMA . E
    (56) E -> . ent
    (57) E -> . dou
    (58) E -> . va
    (59) E -> . str
    (60) E -> . RESTA E
    (61) ent -> . INTEGER
    (62) dou -> . DOUBLE
    (64) va -> . VAR arr
    (65) va -> . VAR
    (63) str -> . STR

    RESTA           shift and go to state 43
    INTEGER         shift and go to state 56
    DOUBLE          shift and go to state 57
    VAR             shift and go to state 55
    STR             shift and go to state 58

    E                              shift and go to state 98
    ent                            shift and go to state 48
    dou                            shift and go to state 49
    va                             shift and go to state 50
    str                            shift and go to state 51

state 65

    (52) expa -> E RESTA . E
    (56) E -> . ent
    (57) E -> . dou
    (58) E -> . va
    (59) E -> . str
    (60) E -> . RESTA E
    (61) ent -> . INTEGER
    (62) dou -> . DOUBLE
    (64) va -> . VAR arr
    (65) va -> . VAR
    (63) str -> . STR

    RESTA           shift and go to state 43
    INTEGER         shift and go to state 56
    DOUBLE          shift and go to state 57
    VAR             shift and go to state 55
    STR             shift and go to state 58

    E                              shift and go to state 99
    ent                            shift and go to state 48
    dou                            shift and go to state 49
    va                             shift and go to state 50
    str                            shift and go to state 51

state 66

    (53) expa -> E MULTI . E
    (56) E -> . ent
    (57) E -> . dou
    (58) E -> . va
    (59) E -> . str
    (60) E -> . RESTA E
    (61) ent -> . INTEGER
    (62) dou -> . DOUBLE
    (64) va -> . VAR arr
    (65) va -> . VAR
    (63) str -> . STR

    RESTA           shift and go to state 43
    INTEGER         shift and go to state 56
    DOUBLE          shift and go to state 57
    VAR             shift and go to state 55
    STR             shift and go to state 58

    E                              shift and go to state 100
    ent                            shift and go to state 48
    dou                            shift and go to state 49
    va                             shift and go to state 50
    str                            shift and go to state 51

state 67

    (55) expa -> E DIV . E
    (56) E -> . ent
    (57) E -> . dou
    (58) E -> . va
    (59) E -> . str
    (60) E -> . RESTA E
    (61) ent -> . INTEGER
    (62) dou -> . DOUBLE
    (64) va -> . VAR arr
    (65) va -> . VAR
    (63) str -> . STR

    RESTA           shift and go to state 43
    INTEGER         shift and go to state 56
    DOUBLE          shift and go to state 57
    VAR             shift and go to state 55
    STR             shift and go to state 58

    E                              shift and go to state 101
    ent                            shift and go to state 48
    dou                            shift and go to state 49
    va                             shift and go to state 50
    str                            shift and go to state 51

state 68

    (36) expl -> E AND . E
    (56) E -> . ent
    (57) E -> . dou
    (58) E -> . va
    (59) E -> . str
    (60) E -> . RESTA E
    (61) ent -> . INTEGER
    (62) dou -> . DOUBLE
    (64) va -> . VAR arr
    (65) va -> . VAR
    (63) str -> . STR

    RESTA           shift and go to state 43
    INTEGER         shift and go to state 56
    DOUBLE          shift and go to state 57
    VAR             shift and go to state 55
    STR             shift and go to state 58

    E                              shift and go to state 102
    ent                            shift and go to state 48
    dou                            shift and go to state 49
    va                             shift and go to state 50
    str                            shift and go to state 51

state 69

    (37) expl -> E OR . E
    (56) E -> . ent
    (57) E -> . dou
    (58) E -> . va
    (59) E -> . str
    (60) E -> . RESTA E
    (61) ent -> . INTEGER
    (62) dou -> . DOUBLE
    (64) va -> . VAR arr
    (65) va -> . VAR
    (63) str -> . STR

    RESTA           shift and go to state 43
    INTEGER         shift and go to state 56
    DOUBLE          shift and go to state 57
    VAR             shift and go to state 55
    STR             shift and go to state 58

    E                              shift and go to state 103
    ent                            shift and go to state 48
    dou                            shift and go to state 49
    va                             shift and go to state 50
    str                            shift and go to state 51

state 70

    (38) expl -> E xor . E
    (56) E -> . ent
    (57) E -> . dou
    (58) E -> . va
    (59) E -> . str
    (60) E -> . RESTA E
    (61) ent -> . INTEGER
    (62) dou -> . DOUBLE
    (64) va -> . VAR arr
    (65) va -> . VAR
    (63) str -> . STR

    RESTA           shift and go to state 43
    INTEGER         shift and go to state 56
    DOUBLE          shift and go to state 57
    VAR             shift and go to state 55
    STR             shift and go to state 58

    E                              shift and go to state 104
    ent                            shift and go to state 48
    dou                            shift and go to state 49
    va                             shift and go to state 50
    str                            shift and go to state 51

state 71

    (39) expra -> E DIGUAL . E
    (56) E -> . ent
    (57) E -> . dou
    (58) E -> . va
    (59) E -> . str
    (60) E -> . RESTA E
    (61) ent -> . INTEGER
    (62) dou -> . DOUBLE
    (64) va -> . VAR arr
    (65) va -> . VAR
    (63) str -> . STR

    RESTA           shift and go to state 43
    INTEGER         shift and go to state 56
    DOUBLE          shift and go to state 57
    VAR             shift and go to state 55
    STR             shift and go to state 58

    E                              shift and go to state 105
    ent                            shift and go to state 48
    dou                            shift and go to state 49
    va                             shift and go to state 50
    str                            shift and go to state 51

state 72

    (40) expra -> E DESIGUAL . E
    (56) E -> . ent
    (57) E -> . dou
    (58) E -> . va
    (59) E -> . str
    (60) E -> . RESTA E
    (61) ent -> . INTEGER
    (62) dou -> . DOUBLE
    (64) va -> . VAR arr
    (65) va -> . VAR
    (63) str -> . STR

    RESTA           shift and go to state 43
    INTEGER         shift and go to state 56
    DOUBLE          shift and go to state 57
    VAR             shift and go to state 55
    STR             shift and go to state 58

    E                              shift and go to state 106
    ent                            shift and go to state 48
    dou                            shift and go to state 49
    va                             shift and go to state 50
    str                            shift and go to state 51

state 73

    (41) expra -> E MAYORIGUAL . E
    (56) E -> . ent
    (57) E -> . dou
    (58) E -> . va
    (59) E -> . str
    (60) E -> . RESTA E
    (61) ent -> . INTEGER
    (62) dou -> . DOUBLE
    (64) va -> . VAR arr
    (65) va -> . VAR
    (63) str -> . STR

    RESTA           shift and go to state 43
    INTEGER         shift and go to state 56
    DOUBLE          shift and go to state 57
    VAR             shift and go to state 55
    STR             shift and go to state 58

    E                              shift and go to state 107
    ent                            shift and go to state 48
    dou                            shift and go to state 49
    va                             shift and go to state 50
    str                            shift and go to state 51

state 74

    (42) expra -> E MENORIGUAL . E
    (56) E -> . ent
    (57) E -> . dou
    (58) E -> . va
    (59) E -> . str
    (60) E -> . RESTA E
    (61) ent -> . INTEGER
    (62) dou -> . DOUBLE
    (64) va -> . VAR arr
    (65) va -> . VAR
    (63) str -> . STR

    RESTA           shift and go to state 43
    INTEGER         shift and go to state 56
    DOUBLE          shift and go to state 57
    VAR             shift and go to state 55
    STR             shift and go to state 58

    E                              shift and go to state 108
    ent                            shift and go to state 48
    dou                            shift and go to state 49
    va                             shift and go to state 50
    str                            shift and go to state 51

state 75

    (43) expra -> E MAYOR . E
    (56) E -> . ent
    (57) E -> . dou
    (58) E -> . va
    (59) E -> . str
    (60) E -> . RESTA E
    (61) ent -> . INTEGER
    (62) dou -> . DOUBLE
    (64) va -> . VAR arr
    (65) va -> . VAR
    (63) str -> . STR

    RESTA           shift and go to state 43
    INTEGER         shift and go to state 56
    DOUBLE          shift and go to state 57
    VAR             shift and go to state 55
    STR             shift and go to state 58

    E                              shift and go to state 109
    ent                            shift and go to state 48
    dou                            shift and go to state 49
    va                             shift and go to state 50
    str                            shift and go to state 51

state 76

    (44) expra -> E MENOR . E
    (56) E -> . ent
    (57) E -> . dou
    (58) E -> . va
    (59) E -> . str
    (60) E -> . RESTA E
    (61) ent -> . INTEGER
    (62) dou -> . DOUBLE
    (64) va -> . VAR arr
    (65) va -> . VAR
    (63) str -> . STR

    RESTA           shift and go to state 43
    INTEGER         shift and go to state 56
    DOUBLE          shift and go to state 57
    VAR             shift and go to state 55
    STR             shift and go to state 58

    E                              shift and go to state 110
    ent                            shift and go to state 48
    dou                            shift and go to state 49
    va                             shift and go to state 50
    str                            shift and go to state 51

state 77

    (46) expb -> E BAND . E
    (56) E -> . ent
    (57) E -> . dou
    (58) E -> . va
    (59) E -> . str
    (60) E -> . RESTA E
    (61) ent -> . INTEGER
    (62) dou -> . DOUBLE
    (64) va -> . VAR arr
    (65) va -> . VAR
    (63) str -> . STR

    RESTA           shift and go to state 43
    INTEGER         shift and go to state 56
    DOUBLE          shift and go to state 57
    VAR             shift and go to state 55
    STR             shift and go to state 58

    E                              shift and go to state 111
    ent                            shift and go to state 48
    dou                            shift and go to state 49
    va                             shift and go to state 50
    str                            shift and go to state 51

state 78

    (47) expb -> E BOR . E
    (56) E -> . ent
    (57) E -> . dou
    (58) E -> . va
    (59) E -> . str
    (60) E -> . RESTA E
    (61) ent -> . INTEGER
    (62) dou -> . DOUBLE
    (64) va -> . VAR arr
    (65) va -> . VAR
    (63) str -> . STR

    RESTA           shift and go to state 43
    INTEGER         shift and go to state 56
    DOUBLE          shift and go to state 57
    VAR             shift and go to state 55
    STR             shift and go to state 58

    E                              shift and go to state 112
    ent                            shift and go to state 48
    dou                            shift and go to state 49
    va                             shift and go to state 50
    str                            shift and go to state 51

state 79

    (48) expb -> E BXOR . E
    (56) E -> . ent
    (57) E -> . dou
    (58) E -> . va
    (59) E -> . str
    (60) E -> . RESTA E
    (61) ent -> . INTEGER
    (62) dou -> . DOUBLE
    (64) va -> . VAR arr
    (65) va -> . VAR
    (63) str -> . STR

    RESTA           shift and go to state 43
    INTEGER         shift and go to state 56
    DOUBLE          shift and go to state 57
    VAR             shift and go to state 55
    STR             shift and go to state 58

    E                              shift and go to state 113
    ent                            shift and go to state 48
    dou                            shift and go to state 49
    va                             shift and go to state 50
    str                            shift and go to state 51

state 80

    (49) expb -> E BLEFT . E
    (56) E -> . ent
    (57) E -> . dou
    (58) E -> . va
    (59) E -> . str
    (60) E -> . RESTA E
    (61) ent -> . INTEGER
    (62) dou -> . DOUBLE
    (64) va -> . VAR arr
    (65) va -> . VAR
    (63) str -> . STR

    RESTA           shift and go to state 43
    INTEGER         shift and go to state 56
    DOUBLE          shift and go to state 57
    VAR             shift and go to state 55
    STR             shift and go to state 58

    E                              shift and go to state 114
    ent                            shift and go to state 48
    dou                            shift and go to state 49
    va                             shift and go to state 50
    str                            shift and go to state 51

state 81

    (50) expb -> E BRIGHT . E
    (56) E -> . ent
    (57) E -> . dou
    (58) E -> . va
    (59) E -> . str
    (60) E -> . RESTA E
    (61) ent -> . INTEGER
    (62) dou -> . DOUBLE
    (64) va -> . VAR arr
    (65) va -> . VAR
    (63) str -> . STR

    RESTA           shift and go to state 43
    INTEGER         shift and go to state 56
    DOUBLE          shift and go to state 57
    VAR             shift and go to state 55
    STR             shift and go to state 58

    E                              shift and go to state 115
    ent                            shift and go to state 48
    dou                            shift and go to state 49
    va                             shift and go to state 50
    str                            shift and go to state 51

state 82

    (60) E -> RESTA E .

    SUMA            reduce using rule 60 (E -> RESTA E .)
    RESTA           reduce using rule 60 (E -> RESTA E .)
    MULTI           reduce using rule 60 (E -> RESTA E .)
    DIV             reduce using rule 60 (E -> RESTA E .)
    AND             reduce using rule 60 (E -> RESTA E .)
    OR              reduce using rule 60 (E -> RESTA E .)
    xor             reduce using rule 60 (E -> RESTA E .)
    DIGUAL          reduce using rule 60 (E -> RESTA E .)
    DESIGUAL        reduce using rule 60 (E -> RESTA E .)
    MAYORIGUAL      reduce using rule 60 (E -> RESTA E .)
    MENORIGUAL      reduce using rule 60 (E -> RESTA E .)
    MAYOR           reduce using rule 60 (E -> RESTA E .)
    MENOR           reduce using rule 60 (E -> RESTA E .)
    BAND            reduce using rule 60 (E -> RESTA E .)
    BOR             reduce using rule 60 (E -> RESTA E .)
    BXOR            reduce using rule 60 (E -> RESTA E .)
    BLEFT           reduce using rule 60 (E -> RESTA E .)
    BRIGHT          reduce using rule 60 (E -> RESTA E .)
    PCOMA           reduce using rule 60 (E -> RESTA E .)
    DERPAR          reduce using rule 60 (E -> RESTA E .)
    DERLLAVE        reduce using rule 60 (E -> RESTA E .)


state 83

    (54) expa -> abs IZQPAR . E DERPAR
    (56) E -> . ent
    (57) E -> . dou
    (58) E -> . va
    (59) E -> . str
    (60) E -> . RESTA E
    (61) ent -> . INTEGER
    (62) dou -> . DOUBLE
    (64) va -> . VAR arr
    (65) va -> . VAR
    (63) str -> . STR

    RESTA           shift and go to state 43
    INTEGER         shift and go to state 56
    DOUBLE          shift and go to state 57
    VAR             shift and go to state 55
    STR             shift and go to state 58

    E                              shift and go to state 116
    ent                            shift and go to state 48
    dou                            shift and go to state 49
    va                             shift and go to state 50
    str                            shift and go to state 51

state 84

    (29) casteo -> IZQPAR int . DERPAR E

    DERPAR          shift and go to state 117


state 85

    (30) casteo -> IZQPAR float . DERPAR E

    DERPAR          shift and go to state 118


state 86

    (31) casteo -> IZQPAR char . DERPAR E

    DERPAR          shift and go to state 119


state 87

    (35) expl -> NOT E .

    PCOMA           reduce using rule 35 (expl -> NOT E .)
    DERPAR          reduce using rule 35 (expl -> NOT E .)


state 88

    (45) expb -> BNOT E .

    PCOMA           reduce using rule 45 (expb -> BNOT E .)
    DERPAR          reduce using rule 45 (expb -> BNOT E .)


state 89

    (32) calls -> read IZQPAR . DERPAR

    DERPAR          shift and go to state 120


state 90

    (33) calls -> array IZQPAR . DERPAR

    DERPAR          shift and go to state 121


state 91

    (34) calls -> PUNTERO VAR .

    PCOMA           reduce using rule 34 (calls -> PUNTERO VAR .)
    DERPAR          reduce using rule 34 (calls -> PUNTERO VAR .)


state 92

    (64) va -> VAR arr .
    (66) arr -> arr . IZQLLAVE E DERLLAVE

    SUMA            reduce using rule 64 (va -> VAR arr .)
    RESTA           reduce using rule 64 (va -> VAR arr .)
    MULTI           reduce using rule 64 (va -> VAR arr .)
    DIV             reduce using rule 64 (va -> VAR arr .)
    AND             reduce using rule 64 (va -> VAR arr .)
    OR              reduce using rule 64 (va -> VAR arr .)
    xor             reduce using rule 64 (va -> VAR arr .)
    DIGUAL          reduce using rule 64 (va -> VAR arr .)
    DESIGUAL        reduce using rule 64 (va -> VAR arr .)
    MAYORIGUAL      reduce using rule 64 (va -> VAR arr .)
    MENORIGUAL      reduce using rule 64 (va -> VAR arr .)
    MAYOR           reduce using rule 64 (va -> VAR arr .)
    MENOR           reduce using rule 64 (va -> VAR arr .)
    BAND            reduce using rule 64 (va -> VAR arr .)
    BOR             reduce using rule 64 (va -> VAR arr .)
    BXOR            reduce using rule 64 (va -> VAR arr .)
    BLEFT           reduce using rule 64 (va -> VAR arr .)
    BRIGHT          reduce using rule 64 (va -> VAR arr .)
    PCOMA           reduce using rule 64 (va -> VAR arr .)
    DERPAR          reduce using rule 64 (va -> VAR arr .)
    DERLLAVE        reduce using rule 64 (va -> VAR arr .)
    IZQLLAVE        shift and go to state 62


state 93

    (19) iff -> if IZQPAR exp DERPAR . goto ID

    goto            shift and go to state 122


state 94

    (20) printt -> print IZQPAR E DERPAR .

    PCOMA           reduce using rule 20 (printt -> print IZQPAR E DERPAR .)


state 95

    (12) uns -> unset IZQPAR va DERPAR .

    PCOMA           reduce using rule 12 (uns -> unset IZQPAR va DERPAR .)


state 96

    (66) arr -> arr IZQLLAVE E . DERLLAVE

    DERLLAVE        shift and go to state 123


state 97

    (67) arr -> IZQLLAVE E DERLLAVE .

    IZQLLAVE        reduce using rule 67 (arr -> IZQLLAVE E DERLLAVE .)
    IGUAL           reduce using rule 67 (arr -> IZQLLAVE E DERLLAVE .)
    SUMA            reduce using rule 67 (arr -> IZQLLAVE E DERLLAVE .)
    RESTA           reduce using rule 67 (arr -> IZQLLAVE E DERLLAVE .)
    MULTI           reduce using rule 67 (arr -> IZQLLAVE E DERLLAVE .)
    DIV             reduce using rule 67 (arr -> IZQLLAVE E DERLLAVE .)
    AND             reduce using rule 67 (arr -> IZQLLAVE E DERLLAVE .)
    OR              reduce using rule 67 (arr -> IZQLLAVE E DERLLAVE .)
    xor             reduce using rule 67 (arr -> IZQLLAVE E DERLLAVE .)
    DIGUAL          reduce using rule 67 (arr -> IZQLLAVE E DERLLAVE .)
    DESIGUAL        reduce using rule 67 (arr -> IZQLLAVE E DERLLAVE .)
    MAYORIGUAL      reduce using rule 67 (arr -> IZQLLAVE E DERLLAVE .)
    MENORIGUAL      reduce using rule 67 (arr -> IZQLLAVE E DERLLAVE .)
    MAYOR           reduce using rule 67 (arr -> IZQLLAVE E DERLLAVE .)
    MENOR           reduce using rule 67 (arr -> IZQLLAVE E DERLLAVE .)
    BAND            reduce using rule 67 (arr -> IZQLLAVE E DERLLAVE .)
    BOR             reduce using rule 67 (arr -> IZQLLAVE E DERLLAVE .)
    BXOR            reduce using rule 67 (arr -> IZQLLAVE E DERLLAVE .)
    BLEFT           reduce using rule 67 (arr -> IZQLLAVE E DERLLAVE .)
    BRIGHT          reduce using rule 67 (arr -> IZQLLAVE E DERLLAVE .)
    PCOMA           reduce using rule 67 (arr -> IZQLLAVE E DERLLAVE .)
    DERPAR          reduce using rule 67 (arr -> IZQLLAVE E DERLLAVE .)
    DERLLAVE        reduce using rule 67 (arr -> IZQLLAVE E DERLLAVE .)


state 98

    (51) expa -> E SUMA E .

    PCOMA           reduce using rule 51 (expa -> E SUMA E .)
    DERPAR          reduce using rule 51 (expa -> E SUMA E .)


state 99

    (52) expa -> E RESTA E .

    PCOMA           reduce using rule 52 (expa -> E RESTA E .)
    DERPAR          reduce using rule 52 (expa -> E RESTA E .)


state 100

    (53) expa -> E MULTI E .

    PCOMA           reduce using rule 53 (expa -> E MULTI E .)
    DERPAR          reduce using rule 53 (expa -> E MULTI E .)


state 101

    (55) expa -> E DIV E .

    PCOMA           reduce using rule 55 (expa -> E DIV E .)
    DERPAR          reduce using rule 55 (expa -> E DIV E .)


state 102

    (36) expl -> E AND E .

    PCOMA           reduce using rule 36 (expl -> E AND E .)
    DERPAR          reduce using rule 36 (expl -> E AND E .)


state 103

    (37) expl -> E OR E .

    PCOMA           reduce using rule 37 (expl -> E OR E .)
    DERPAR          reduce using rule 37 (expl -> E OR E .)


state 104

    (38) expl -> E xor E .

    PCOMA           reduce using rule 38 (expl -> E xor E .)
    DERPAR          reduce using rule 38 (expl -> E xor E .)


state 105

    (39) expra -> E DIGUAL E .

    PCOMA           reduce using rule 39 (expra -> E DIGUAL E .)
    DERPAR          reduce using rule 39 (expra -> E DIGUAL E .)


state 106

    (40) expra -> E DESIGUAL E .

    PCOMA           reduce using rule 40 (expra -> E DESIGUAL E .)
    DERPAR          reduce using rule 40 (expra -> E DESIGUAL E .)


state 107

    (41) expra -> E MAYORIGUAL E .

    PCOMA           reduce using rule 41 (expra -> E MAYORIGUAL E .)
    DERPAR          reduce using rule 41 (expra -> E MAYORIGUAL E .)


state 108

    (42) expra -> E MENORIGUAL E .

    PCOMA           reduce using rule 42 (expra -> E MENORIGUAL E .)
    DERPAR          reduce using rule 42 (expra -> E MENORIGUAL E .)


state 109

    (43) expra -> E MAYOR E .

    PCOMA           reduce using rule 43 (expra -> E MAYOR E .)
    DERPAR          reduce using rule 43 (expra -> E MAYOR E .)


state 110

    (44) expra -> E MENOR E .

    PCOMA           reduce using rule 44 (expra -> E MENOR E .)
    DERPAR          reduce using rule 44 (expra -> E MENOR E .)


state 111

    (46) expb -> E BAND E .

    PCOMA           reduce using rule 46 (expb -> E BAND E .)
    DERPAR          reduce using rule 46 (expb -> E BAND E .)


state 112

    (47) expb -> E BOR E .

    PCOMA           reduce using rule 47 (expb -> E BOR E .)
    DERPAR          reduce using rule 47 (expb -> E BOR E .)


state 113

    (48) expb -> E BXOR E .

    PCOMA           reduce using rule 48 (expb -> E BXOR E .)
    DERPAR          reduce using rule 48 (expb -> E BXOR E .)


state 114

    (49) expb -> E BLEFT E .

    PCOMA           reduce using rule 49 (expb -> E BLEFT E .)
    DERPAR          reduce using rule 49 (expb -> E BLEFT E .)


state 115

    (50) expb -> E BRIGHT E .

    PCOMA           reduce using rule 50 (expb -> E BRIGHT E .)
    DERPAR          reduce using rule 50 (expb -> E BRIGHT E .)


state 116

    (54) expa -> abs IZQPAR E . DERPAR

    DERPAR          shift and go to state 124


state 117

    (29) casteo -> IZQPAR int DERPAR . E
    (56) E -> . ent
    (57) E -> . dou
    (58) E -> . va
    (59) E -> . str
    (60) E -> . RESTA E
    (61) ent -> . INTEGER
    (62) dou -> . DOUBLE
    (64) va -> . VAR arr
    (65) va -> . VAR
    (63) str -> . STR

    RESTA           shift and go to state 43
    INTEGER         shift and go to state 56
    DOUBLE          shift and go to state 57
    VAR             shift and go to state 55
    STR             shift and go to state 58

    E                              shift and go to state 125
    ent                            shift and go to state 48
    dou                            shift and go to state 49
    va                             shift and go to state 50
    str                            shift and go to state 51

state 118

    (30) casteo -> IZQPAR float DERPAR . E
    (56) E -> . ent
    (57) E -> . dou
    (58) E -> . va
    (59) E -> . str
    (60) E -> . RESTA E
    (61) ent -> . INTEGER
    (62) dou -> . DOUBLE
    (64) va -> . VAR arr
    (65) va -> . VAR
    (63) str -> . STR

    RESTA           shift and go to state 43
    INTEGER         shift and go to state 56
    DOUBLE          shift and go to state 57
    VAR             shift and go to state 55
    STR             shift and go to state 58

    E                              shift and go to state 126
    ent                            shift and go to state 48
    dou                            shift and go to state 49
    va                             shift and go to state 50
    str                            shift and go to state 51

state 119

    (31) casteo -> IZQPAR char DERPAR . E
    (56) E -> . ent
    (57) E -> . dou
    (58) E -> . va
    (59) E -> . str
    (60) E -> . RESTA E
    (61) ent -> . INTEGER
    (62) dou -> . DOUBLE
    (64) va -> . VAR arr
    (65) va -> . VAR
    (63) str -> . STR

    RESTA           shift and go to state 43
    INTEGER         shift and go to state 56
    DOUBLE          shift and go to state 57
    VAR             shift and go to state 55
    STR             shift and go to state 58

    E                              shift and go to state 127
    ent                            shift and go to state 48
    dou                            shift and go to state 49
    va                             shift and go to state 50
    str                            shift and go to state 51

state 120

    (32) calls -> read IZQPAR DERPAR .

    PCOMA           reduce using rule 32 (calls -> read IZQPAR DERPAR .)
    DERPAR          reduce using rule 32 (calls -> read IZQPAR DERPAR .)


state 121

    (33) calls -> array IZQPAR DERPAR .

    PCOMA           reduce using rule 33 (calls -> array IZQPAR DERPAR .)
    DERPAR          reduce using rule 33 (calls -> array IZQPAR DERPAR .)


state 122

    (19) iff -> if IZQPAR exp DERPAR goto . ID

    ID              shift and go to state 128


state 123

    (66) arr -> arr IZQLLAVE E DERLLAVE .

    IZQLLAVE        reduce using rule 66 (arr -> arr IZQLLAVE E DERLLAVE .)
    IGUAL           reduce using rule 66 (arr -> arr IZQLLAVE E DERLLAVE .)
    SUMA            reduce using rule 66 (arr -> arr IZQLLAVE E DERLLAVE .)
    RESTA           reduce using rule 66 (arr -> arr IZQLLAVE E DERLLAVE .)
    MULTI           reduce using rule 66 (arr -> arr IZQLLAVE E DERLLAVE .)
    DIV             reduce using rule 66 (arr -> arr IZQLLAVE E DERLLAVE .)
    AND             reduce using rule 66 (arr -> arr IZQLLAVE E DERLLAVE .)
    OR              reduce using rule 66 (arr -> arr IZQLLAVE E DERLLAVE .)
    xor             reduce using rule 66 (arr -> arr IZQLLAVE E DERLLAVE .)
    DIGUAL          reduce using rule 66 (arr -> arr IZQLLAVE E DERLLAVE .)
    DESIGUAL        reduce using rule 66 (arr -> arr IZQLLAVE E DERLLAVE .)
    MAYORIGUAL      reduce using rule 66 (arr -> arr IZQLLAVE E DERLLAVE .)
    MENORIGUAL      reduce using rule 66 (arr -> arr IZQLLAVE E DERLLAVE .)
    MAYOR           reduce using rule 66 (arr -> arr IZQLLAVE E DERLLAVE .)
    MENOR           reduce using rule 66 (arr -> arr IZQLLAVE E DERLLAVE .)
    BAND            reduce using rule 66 (arr -> arr IZQLLAVE E DERLLAVE .)
    BOR             reduce using rule 66 (arr -> arr IZQLLAVE E DERLLAVE .)
    BXOR            reduce using rule 66 (arr -> arr IZQLLAVE E DERLLAVE .)
    BLEFT           reduce using rule 66 (arr -> arr IZQLLAVE E DERLLAVE .)
    BRIGHT          reduce using rule 66 (arr -> arr IZQLLAVE E DERLLAVE .)
    PCOMA           reduce using rule 66 (arr -> arr IZQLLAVE E DERLLAVE .)
    DERPAR          reduce using rule 66 (arr -> arr IZQLLAVE E DERLLAVE .)
    DERLLAVE        reduce using rule 66 (arr -> arr IZQLLAVE E DERLLAVE .)


state 124

    (54) expa -> abs IZQPAR E DERPAR .

    PCOMA           reduce using rule 54 (expa -> abs IZQPAR E DERPAR .)
    DERPAR          reduce using rule 54 (expa -> abs IZQPAR E DERPAR .)


state 125

    (29) casteo -> IZQPAR int DERPAR E .

    PCOMA           reduce using rule 29 (casteo -> IZQPAR int DERPAR E .)
    DERPAR          reduce using rule 29 (casteo -> IZQPAR int DERPAR E .)


state 126

    (30) casteo -> IZQPAR float DERPAR E .

    PCOMA           reduce using rule 30 (casteo -> IZQPAR float DERPAR E .)
    DERPAR          reduce using rule 30 (casteo -> IZQPAR float DERPAR E .)


state 127

    (31) casteo -> IZQPAR char DERPAR E .

    PCOMA           reduce using rule 31 (casteo -> IZQPAR char DERPAR E .)
    DERPAR          reduce using rule 31 (casteo -> IZQPAR char DERPAR E .)


state 128

    (19) iff -> if IZQPAR exp DERPAR goto ID .

    PCOMA           reduce using rule 19 (iff -> if IZQPAR exp DERPAR goto ID .)

